import React, { PureComponent, Fragment } from 'react'
import styled from 'react-emotion'
import axios from 'axios'
import MdInfoOutline from 'react-icons/lib/md/info-outline'
import MdClose from 'react-icons/lib/md/close'
import throttle from 'lodash.throttle'
import bnc from 'bnc-assist'

import { Consumer } from '../stores/AppState'
import { Main, Div } from '../base-components'

import {
  FileShowCard,
  Carousel,
  SignMessage,
  PurchaseFiles,
  DownloadFile,
  Downloading,
  DownloadComplete,
  EnzyptHeader,
  ErrorPopup,
  CanvasShapes,
  Info
} from '../components'

import { BuiltByFlex, FaqIcon } from '../elements'

import { API_URL, NETWORK } from '../config'
import { getColor } from '../utilities/utilities'

import Web3 from 'web3'
const web3 = new Web3(
  Web3.givenProvider || 'https://mainnet.infura.io/T1YIsUqqHW568dijGClq'
)

const MESSAGE_TO_SIGN =
  'This is a message generated by enzypt.io, by signing this message you are proving that you own the address: %.\nRandom string: %'

// ---------- COMPONENT ----------- //

class Buy extends PureComponent {
  constructor(props) {
    super(props)
    const urlParts = props.location.pathname.split('/')

    this.state = {
      showInfo: true,
      innerHeight: window.innerHeight,
      name: '....',
      price: '....',
      size: '....',
      sellerEthAddress: '....',
      downloads: '....',
      publicKey: null,
      randomString: null,
      fileUrl: urlParts[1],
      dKey: urlParts[2],
      iv: null,
      metaFileHash: null,
      installMetamask: false,
      wrongNetwork: false,
      paymentReference: '',
      paymentTxReceipt: '',
      downloadPercent: 0,
      color: '#ff71ce',
      zipFileHash: null,
      errorMsg: '',
      assist: null
    }
  }

  componentDidMount = () => {
    this.getMetaFileHash()
    window.addEventListener('resize', throttle(this.handleResize, 150))
  }

  handleResize = () => {
    this.setState({ innerHeight: window.innerHeight })
  }

  toggleInfo = () => {
    this.setState(({ showInfo }) => ({ showInfo: !showInfo }))
  }

  checkIfMainnet = async () => {
    const { wrongNetwork } = this.state
    if (web3.eth && web3.eth.net.getId) {
      const networkId = await web3.eth.net.getId()
      if (networkId !== NETWORK) {
        this.setState({
          wrongNetwork: true
        })
      } else if (wrongNetwork) {
        this.setState({ wrongNetwork: false })
      }
    }
    setTimeout(this.checkIfMainnet, 5000)
  }

  getMetamaskAccount = async () => {
    const assist = bnc.init({
      dappId: '61db946a-6060-4cdc-b9a2-8718de184eec',
      networkId: NETWORK,
      web3: web3,
      style: {
        darkMode: true
      }
    })

    this.setState({
      assist: assist
    })

    try {
      await assist.onboard()
    } catch (e) {
      console.log(e)
    }

    let accounts
    if (window.ethereum) {
      accounts = await window.ethereum.enable()
    }

    if (window.web3 && web3.currentProvider) {
      accounts = await web3.eth.getAccounts()
    }

    if (accounts[0]) {
      this.setState(
        {
          installMetamask: false,
          publicKey: accounts[0].toLowerCase()
        },
        () => this.getRandomString(this.state.publicKey)
      )
      return
    } else {
      this.setState({ installMetamask: true })
    }

    setTimeout(this.getMetamaskAccount, 500)
  }

  getMetaFileHash = async () => {
    const result = await axios.get(API_URL + '/' + this.state.fileUrl)

    this.setState({
      metaFileHash: result.data.metaFileHash,
      iv: result.data.iv,
      downloads: result.data.downloads
    })

    // now that we have the meta file hash we can go get it and decrypt it
    const decrypted = await this.getAndDecryptFile(
      this.state.metaFileHash,
      'meta'
    )
    const textDecoder = new TextDecoder('utf-8')
    const decoded = textDecoder.decode(decrypted)
    const fileMeta = JSON.parse(decoded)
    this.setState({
      name: fileMeta.name,
      price: fileMeta.price,
      size: fileMeta.totalFileSize,
      sellerEthAddress: fileMeta.sellerEthAddress,
      files: fileMeta.files
    })
    if (result.data.zipFileHash) {
      this.setState({
        paymentReference: true,
        paymentTxHash: true,
        paymentTxReceipt: true,
        zipFileHash: result.data.zipFileHash
      })
    } else {
      this.getMetamaskAccount()
      this.checkIfMainnet()
    }
  }

  getAndDecryptFile = async (_fileHash, meta) => {
    // go get it from IPFS
    const result = await axios({
      method: 'get',
      url: 'https://ipfs.enzypt.io/ipfs/' + _fileHash,
      responseType: 'arraybuffer',
      onDownloadProgress: meta
        ? null
        : event => {
            let percentCompleted = Math.floor(
              event.loaded / (event.total / 100)
            )
            if (percentCompleted === 99) {
              percentCompleted = 100
            }
            this.setState({
              downloadPercent: percentCompleted,
              color: getColor(percentCompleted)
            })
          }
    })
    let decrypted = await this.decryptFile(result.data)
    return decrypted
  }

  decryptFile = async _encryptedData => {
    // decrypt any file given the data
    const fileBuffer = new Buffer(_encryptedData)
    const dKey = {
      alg: 'A256CBC',
      ext: true,
      k: this.state.dKey,
      key_ops: ['encrypt', 'decrypt'],
      kty: 'oct'
    }
    const iv = new Uint8Array(16)
    for (let index in this.state.iv) {
      iv[index] = this.state.iv[index]
    }
    const algo = { name: 'AES-CBC', iv: iv }
    try {
      const key = await crypto.subtle.importKey('jwk', dKey, algo, true, [
        'encrypt',
        'decrypt'
      ])
      let decrypted = await crypto.subtle.decrypt(algo, key, fileBuffer)
      return decrypted
    } catch (e) {
      alert(e.toString())
    }
  }

  getRandomString = async _ethAddress => {
    const randomString = await axios.post(API_URL + '/rand', {
      publicKey: _ethAddress
    })
    this.setState({ randomString: randomString.data })
  }

  getDataToSign = () => {
    const { publicKey, randomString } = this.state
    if (publicKey == null || randomString == null) {
      throw Error('publicKey or randomString are null')
    }
    const dataToSign = web3.utils.toHex(
      MESSAGE_TO_SIGN.replace('%', publicKey.toLowerCase()).replace(
        '%',
        randomString
      )
    )
    return dataToSign
  }

  signMessage = () => {
    try {
      const { publicKey } = this.state
      const dataToSign = this.getDataToSign()
      web3.currentProvider.send(
        { method: 'personal_sign', params: [dataToSign, publicKey] },
        (e, res) => {
          this.setState({ signedMessage: res.result })
          this.postSignedMessage()
          if (res.error) {
            this.setState({errorMsg: 'Message signature canceled'})
          }
        }
      )
    } catch (e) {
      setTimeout(this.signMessage, 1000)
    }
  }

  postSignedMessage = async () => {
    const { signedMessage, publicKey, fileUrl } = this.state
    const result = await axios.post(API_URL + '/msg', {
      signedMessage: signedMessage,
      publicKey: publicKey,
      urlSlug: fileUrl
    })
    if (result.data.randomHex) {
      this.setState({ paymentReference: result.data.randomHex.toLowerCase() })
      return
    }
    if (result.data.zipFileHash) {
      this.setState({
        paymentReference: true,
        paymentTxHash: true,
        paymentTxReceipt: true,
        zipFileHash: result.data.zipFileHash
      })
    }
  }

  purchaseFile = async () => {
    const txObject = {
      value: web3.utils.toWei(this.state.price, 'ether'),
      to: this.state.sellerEthAddress,
      from: this.state.publicKey,
      data: this.state.paymentReference,
      gas: 25000
    }

    const { txPromise } = await this.state.assist.Transaction(txObject, null, {
      txRequest: () => `Please confirm the transaction`,
      txSent: () => `Sending transaction`,
      txPending: () =>
        `Purchasing ${this.state.name} for ${this.state.price} ETH`,
      txConfirmed: () => {
        this.setState({ paymentTxReceipt: true })
        return `Purchase complete`
      }
    })

    txPromise
      .once('transactionHash', hash => {
        this.setState({ paymentTxHash: hash })
      })
      .once('receipt', receipt => {
        this.setState({ paymentTxReceipt: receipt })
      })
      .on('error', e => this.setState({ errorMsg: 'Payment was rejected' }))
  }

  postPurchaseConfirmation = async () => {
    if (!this.state.zipFileHash) {
      try {
        var result = await axios.post(API_URL + '/buy', {
          txHash: this.state.paymentTxHash
        })
      } catch (e) {
        alert(e)
      }
      this.unzipDecryptDownload(result.data)
    } else {
      this.unzipDecryptDownload(this.state.zipFileHash)
    }
  }

  unzipDecryptDownload = async zipHash => {
    const decrypted = await this.getAndDecryptFile(zipHash)
    const { files } = this.state
    const blob = new Blob([decrypted])
    const link = document.createElement('a')
    link.href = URL.createObjectURL(blob)
    link.style = 'display: none;'
    document.body.appendChild(link)
    if (files.length === 1) {
      link.download = files[0].name
    } else {
      link.download = this.state.name + '.zip'
    }
    link.click()
  }

  render() {
    const {
      showInfo,
      innerHeight,
      name,
      price,
      size,
      downloads,
      sellerEthAddress,
      paymentReference,
      paymentTxReceipt,
      color,
      downloadPercent,
      zipFileHash,
      errorMsg
    } = this.state

    const { toggleInfo } = this

    return (
      <Fragment>
        <CanvasShapes />
        <AbsoluteMain height={`${innerHeight}px`} padding="1rem">
          <EnzyptHeader />
          {showInfo ? (
            <CloseButton onClick={toggleInfo} />
          ) : (
            <InfoButton onClick={toggleInfo} />
          )}
          <AppContainer
            maxWidth="800px"
            height="90%"
            maxHeight="700px"
            overflow="visible"
          >
            <Carousel width="45%" height="100%">
              <Carousel.Slide>
                <SignMessage
                  signMessage={this.signMessage}
                  skip={!!zipFileHash}
                />
              </Carousel.Slide>
              <Carousel.Slide>
                {errorMsg ? (
                  <ErrorPopup message={errorMsg} />
                ) : (
                  <PurchaseFiles
                    loading={!paymentReference}
                    name={name}
                    price={price}
                    zipFileHash={zipFileHash}
                    purchaseFile={() => this.purchaseFile()}
                  />
                )}
              </Carousel.Slide>
              <Carousel.Slide>
                {errorMsg ? (
                  <ErrorPopup message={errorMsg} />
                ) : (
                  <DownloadFile
                    loading={!paymentTxReceipt}
                    downloadFile={() => this.postPurchaseConfirmation()}
                    previousPurchase={zipFileHash}
                    free={price === '0'}
                  />
                )}
              </Carousel.Slide>
              <Carousel.Slide>
                <Downloading color={color} downloadPercent={downloadPercent} />
              </Carousel.Slide>
              <Carousel.Slide>
                <DownloadComplete />
              </Carousel.Slide>
            </Carousel>
            <Consumer>
              {({ userEthConversionRate, userCurrency }) => (
                <FileShowCard
                  height="100%"
                  width="45%"
                  name={name + '.zip'}
                  price={price}
                  userEthConversionRate={userEthConversionRate}
                  userCurrency={userCurrency}
                  size={size}
                  sellerEthAddress={sellerEthAddress}
                  downloads={downloads}
                />
              )}
            </Consumer>
          </AppContainer>
          <FaqIcon />
          <Info visible={showInfo} />
          <BuiltByFlex />
        </AbsoluteMain>
      </Fragment>
    )
  }
}

export default Buy

const AbsoluteMain = styled(Main)`
  position: absolute;
  z-index: 1;
  overflow: hidden;
  @media (max-width: 1024px) {
    min-height: 568px;
  }
`

const InfoButton = styled(MdInfoOutline)`
  color: ${({ theme }) => theme.colors.success};
  position: fixed;
  top: 1rem;
  right: 1rem;
  font-size: 2rem;
  z-index: 2;
  &:hover {
    cursor: pointer;
  }
`
const CloseButton = InfoButton.withComponent(MdClose)

const AppContainer = styled(Div)`
  top: 1rem;
`
